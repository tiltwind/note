<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="//vogo.github.io/markhtml/css/markhtml.css">
    <title>Index</title>
</head>
<body class="markdown-body">
    <div id="navbar"></div>
    <div id="menu"></div>
    <div class="main" id="app">

<!--
markmeta_author: titlwind
markmeta_date: 2025-11-07
markmeta_title: Spec-Driven Development
markmeta_categories: ai
markmeta_tags: ai,spec
-->

<h1>Spec-Driven Development 规范驱动开发</h1>

<h2>1. 背景</h2>

<p>随着 AI 编码能力的增强，一个常见模式是：你描述目标，AI 返回代码块，看起来正确但常常无法直接运行。
这种“氛围编程” (vibe-coding) 方法适合快速原型，但对于严肃、关键任务的应用或在现有代码库中工作时，可靠性较低。</p>

<p>问题不在于 AI 的编码能力，而在于我们的方法。
我们像对待搜索引擎一样对待 AI 编码，而实际上应该把它们看作是需要明确指令的“结对程序员”。</p>

<p>为了解决这个问题，规范驱动开发 (Spec-Driven Development, SDD) 应运而生。
它将规范 (specifications) 重新定义为动态的、可执行的工件，随项目一同演进，成为共享的真理来源。</p>

<blockquote>
<p>扩展: TDD (Test-Driven Development) 也是一种流行的AI编程模式, 它的核心思想是先写测试用例，然后根据测试用例编写代码，确保代码符合预期。</p>
</blockquote>

<h2>2. 定义</h2>

<p>规范驱动开发 (Spec-Driven Development, SDD) 是一种软件开发方法，它将传统的开发流程颠倒过来。
规范不再是编码开始后就被丢弃的脚手架，而是成为可执行的，能直接生成工作实现的核心。</p>

<p><strong>在这种模式下，开发者首先与 AI 协作，创建一份详细、清晰且可执行的规范文档，这份文档定义了要构建什么以及为什么构建。然后，这份规范将驱动技术规划、任务分解和最终的代码实现。</strong></p>

<p><strong>核心优势</strong></p>

<ul>
<li><strong>统一团队目标</strong>: 共享的规范文档确保所有人对目标有统一理解。</li>
<li><strong>减少返工成本</strong>: 前置规划减少因需求不明确导致的返工。</li>
<li><strong>提升代码质量</strong>: 基于严谨规范生成的代码通常结构更合理。</li>
<li><strong>加速开发周期</strong>: 规范确定后，代码生成和开发效率大幅提升。</li>
</ul>

<p><strong>本质上，SDD是一种编程上下文工程方法，提供更清晰的上下文，确保 AI 生成的代码符合预期。</strong></p>

<h3>2.1 核心观点</h3>

<ul>
<li><strong>权力反转</strong>：规范为王，代码服务规范。PRD 与技术计划不是“指导编码”的文档，而是生成实现的源头。</li>
<li><strong>消除鸿沟</strong>：让“规范—实现计划—代码”成为可执行的连续体，消除传统上规范与代码之间的断裂。</li>
<li><strong>AI 赋能但需结构</strong>：AI 能理解并实现复杂规范，但如果缺少结构化规范与实现计划，生成会失控。SDD 提供结构与约束。</li>
<li><strong>意图驱动开发</strong>：团队的开发意图以自然语言、设计资产、原则表达；代码只是最后一公里的表达形式。</li>
<li><strong>维护即演化规范</strong>：调试意味着修正规范与实现计划；重构意味着提升清晰度；增量开发从规范的更新开始。</li>
</ul>

<h3>2.2 为什么重要（当下的必要性）</h3>

<ul>
<li><strong>一致性与可追溯</strong>：每个技术决策都能追溯到明确的需求与验收标准。</li>
<li><strong>让 SDLC 连续化</strong>：需求与设计不再是一次性阶段，而是贯穿开发的持续活动。</li>
<li><strong>组织治理自动化</strong>：数据库、认证、部署等组织约束能够自动融入规范与计划。</li>
<li><strong>质量提升</strong>：一致性验证、歧义检测与缺口识别贯穿规范与计划的迭代过程。</li>
<li><strong>快速试错</strong>：早期代码生成用于验证规范的可行性与可测试性，从而更快收敛到正确的实现。</li>
</ul>

<h3>2.3 核心原则</h3>

<ul>
<li><strong>规范是唯一事实来源</strong>：规范与实现计划共同构成真实的源头，代码是它们的表达。</li>
<li><strong>规范必须可执行、完整、无歧义</strong>：具备清晰目标、用户故事、验收标准与边界条件。</li>
<li><strong>实现计划是技术映射</strong>：从规范到架构、模型、接口、错误处理、测试与部署的具体定义。</li>
<li><strong>一致性验证贯穿始终</strong>：持续检查规范、计划与任务之间的内在一致性。</li>
<li><strong>变更从规范开始</strong>：先调整规范与计划，再重生成代码，而非直接“手改代码”。</li>
<li><strong>分支化协作</strong>：规范与计划像代码一样可审查、版本化、合并。</li>
</ul>

<h3>2.4 实现方法（操作要点）</h3>

<ul>
<li><strong>规范结构</strong>：阐明目标、用户场景与故事、验收标准、非功能性要求、边界条件。</li>
<li><strong>实现计划结构</strong>：选择架构与模式、定义数据模型与接口、错误与异常策略、测试方案、部署与回滚策略。</li>
<li><strong>审查清单</strong>：完整性、无歧义、可测试性、一致性、可追溯性与风险说明。</li>
<li><strong>验证循环</strong>：小步生成→运行验证→收集反馈→精炼规范与计划→再生成。</li>
<li><strong>研究代理集成</strong>：调研库兼容性、性能、安全与组织约束；将结果自动应用于规范。</li>
<li><strong>变更管理</strong>：规范更新后，计划自动标记受影响的技术决策与任务，确保变更范围可控。</li>
</ul>

<h2>3. 使用方式 (流程)</h2>

<p>规范驱动开发通常遵循一个结构化的流程，每个阶段都有明确的任务和验证点。
开发者在其中扮演引导和验证的角色，而 AI 则负责大部分的撰写工作。</p>

<p>一个典型的流程分为四个阶段：</p>

<ol>
<li><strong>Specify (规范)</strong>: 开发者提供高层次描述（用户旅程、体验、成功标准），AI 生成详细的功能规范。这个阶段关注 <strong>“什么”</strong> 和 <strong>“为什么”</strong>，而不是技术实现。</li>
<li><strong>Plan (规划)</strong>: 开发者提供技术栈、架构和约束，AI 生成全面的技术计划。这个阶段关注 <strong>“如何”</strong> 构建。</li>
<li><strong>Tasks (任务)</strong>: AI 将规范和计划分解为小的、可审查、可独立测试的工作单元。</li>
<li><strong>Implement (实现)</strong>: AI 逐一完成任务。开发者审查的是专注、解决特定问题的代码变更，而不是庞大的代码转储。</li>
</ol>

<p>在每个阶段，开发者都需要 <strong>验证和修正</strong> AI 生成的产出，确保其符合真实需求和约束。</p>

<h3>3.1 工作流细化（与团队协作）</h3>

<ul>
<li><strong>从想法到 PRD</strong>：通过与 AI 的迭代对话形成完整、可执行的 PRD，包含验收标准与边界场景。</li>
<li><strong>从 PRD 到实现计划</strong>：将需求映射为技术决策，每个选择记录理由并可追溯到具体需求。</li>
<li><strong>一致性验证</strong>：在规范、计划与任务之间持续执行歧义检测、矛盾分析与缺口识别。</li>
<li><strong>代码生成与探索性迭代</strong>：在规范与计划足够稳定时开始生成；早期生成用于试探与验证规范合理性。</li>
<li><strong>版本化协作</strong>：规范与计划在分支中评审与合并，成为团队的共享事实来源。</li>
</ul>

<h3>3.2 实践建议（落地到工具）</h3>

<ul>
<li><strong>与 Spec-Kit 对齐</strong>：按 specify/plan/tasks/implement 组织步骤；结合 constitution 先立原则，clarify 解决歧义，analyze 做一致性检查。</li>
<li><strong>任务粒度</strong>：拆成可独立测试的小单元，保证每步都能审查与回滚。</li>
<li><strong>质量门槛</strong>：在每次计划变更后运行 checklist 验证规范质量与可测试性。</li>
<li><strong>Bug 修复纳入规范</strong>：记录→分析根因→更新规范与计划→生成修复→验证；避免仅在代码层面“打补丁”。</li>
<li><strong>变更先于实现</strong>：任何重大重构或功能扩展，先更新规范与计划，再生成并审查代码。</li>
</ul>

<h2>4. Spec-Kit</h2>

<p><code>Spec-Kit</code> 是 GitHub 推出的开源工具包，旨在将规范驱动开发带入开发者的 AI 工作流中。</p>

<h3>4.1 Spec-Kit 核心功能</h3>

<p><code>Spec-Kit</code> 提供了一系列命令行工具和模板，与 Cursor、Claude Code、Gemini CLI 等 AI 编码工具深度集成。它包含四阶段核心工作流和一些辅助命令。</p>

<p><strong>核心工作流</strong></p>

<ul>
<li><code>/speckit.specify</code>: 将功能需求转化为清晰的规范文档。</li>
<li><code>/speckit.plan</code>: 制定功能的技术实现方案。</li>
<li><code>/speckit.tasks</code>: 将技术方案分解为可执行的任务清单。</li>
<li><code>/speckit.implement</code>: 按任务清单逐步实现功能代码。</li>
</ul>

<p><strong>辅助命令</strong></p>

<ul>
<li><code>/speckit.constitution</code>: 定义项目的核心原则和开发规范。</li>
<li><code>/speckit.clarify</code>: 解决规范中的模糊和歧义问题。</li>
<li><code>/speckit.analyze</code>: 检查规范、计划、任务的一致性。</li>
<li><code>/speckit.checklist</code>: 生成需求质量验证清单。</li>
</ul>

<h3>4.2 Spec-Kit 使用方式</h3>

<ol>
<li><strong>安装 <code>specify-cli</code></strong>:</li>
</ol>

<pre><code class="language-bash">uv tool install specify-cli --from git+https://github.com/github/spec-kit.git

# upgrade
uv tool install specify-cli --force --from git+https://github.com/github/spec-kit.git
</code></pre>

<ol>
<li><strong>初始化项目</strong>:</li>
</ol>

<p>在项目目录中，使用 AI 助手（如 Cursor）运行初始化命令，并指定 AI 代理。</p>

<pre><code class="language-bash">specify init . --ai cursor
</code></pre>

<ol>
<li><strong>执行工作流</strong>:</li>
</ol>

<p>在 AI 助手的聊天框中，依次使用 <code>/speckit.*</code> 命令来完成开发流程。</p>

<pre><code class="language-bash"># 1. 创建规范
/speckit.specify 开发一个用户注册功能...

# 2. 制定计划
/speckit.plan 使用 React 和 aaaa UI 库...

# 3. 分解任务
/speckit.tasks

# 4. 实现代码
/speckit.implement
</code></pre>

<h2>5. Claude Code Spec Workflow</h2>

<p><code>claude-code-spec-workflow</code> 是一个针对 Claude Code 的自动化工作流项目，它实现了规范驱动开发和 Bug 修复的流程。</p>

<blockquote>
<p><strong>注意</strong>: 该项目的开发重点已转移到提供更强功能和更广泛兼容性的 MCP (Model Context Protocol) 版本。</p>
</blockquote>

<h3>5.1 Claude Code Spec Workflow 核心功能</h3>

<p>该工作流为 Claude Code 提供了智能任务执行、专用代理、实时仪表盘等功能。</p>

<p><strong>规范工作流 (新功能)</strong></p>

<ul>
<li><code>/spec-create</code>: 一键完成从需求 -&gt; 设计 -&gt; 任务 -&gt; 命令生成的完整流程。</li>
<li><code>/spec-execute</code>: 手动执行单个任务。</li>
</ul>

<p><strong>Bug 修复工作流</strong></p>

<ul>
<li><code>/bug-create</code>: 记录 Bug。</li>
<li><code>/bug-analyze</code>: 分析根本原因。</li>
<li><code>/bug-fix</code>: 实现解决方案。</li>
<li><code>/bug-verify</code>: 验证修复。</li>
</ul>

<h3>5.2 Claude Code Spec Workflow 使用方式</h3>

<ol>
<li><strong>全局安装</strong>:</li>
</ol>

<pre><code class="language-bash">npm i -g @pimzino/claude-code-spec-workflow
</code></pre>

<ol>
<li><strong>在项目中设置</strong>:</li>
</ol>

<pre><code class="language-bash">claude-code-spec-workflow

# This will create:
#   .claude/ directory structure
#   14 slash commands (9 spec workflow + 5 bug fix workflow)
#   Auto-generated task commands for existing specs
#   Intelligent orchestrator for automated execution
#   Document templates
#   NPX-based task command generation
#   Complete workflow instructions embedded in each command
#   Claude Code sub-agents (mandatory)
# 
# ✔ Installation completed!
# 
# Spec Workflow installation completed successfully!

tree .claude
# .claude
# ├── agents
# │   ├── spec-design-validator.md
# │   ├── spec-requirements-validator.md
# │   ├── spec-task-executor.md
# │   └── spec-task-validator.md
# ├── bugs
# ├── commands
# │   ├── bug-analyze.md
# │   ├── bug-create.md
# │   ├── bug-fix.md
# │   ├── bug-status.md
# │   ├── bug-verify.md
# │   ├── spec-create.md
# │   ├── spec-execute.md
# │   ├── spec-list.md
# │   ├── spec-status.md
# │   └── spec-steering-setup.md
# ├── settings.local.json
# ├── specs
# ├── steering
# └── templates
#     ├── bug-analysis-template.md
#     ├── bug-report-template.md
#     ├── bug-verification-template.md
#     ├── design-template.md
#     ├── product-template.md
#     ├── requirements-template.md
#     ├── structure-template.md
#     ├── tasks-template.md
#     └── tech-template.md
# 
# 7 directories, 24 files
</code></pre>

<ol>
<li><strong>使用斜杠命令</strong>:</li>
</ol>

<p>使用斜杠命令来驱动工作流。例如，开发一个新功能：</p>

<pre><code class="language-bash"># 创建项目上下文文档
/spec-steering-setup

# 描述需求后，一键创建规范和任务
/spec-create lingolearn-app &quot;开发一个单词卡片应用...&quot;

# 逐个执行生成的任务
/spec-execute 1 lingolearn-app
</code></pre>

<h4>执行效果说明</h4>

<ul>
<li><p><code>/spec-steering-setup</code></p>

<ul>
<li>初始化项目“共同上下文”与指导文档：项目背景与目标、组织/技术约束、核心原则、命名与目录约定、质量门槛等。</li>
<li>建立工作流所需的基本配置，供后续规范与实现计划的生成复用。</li>
</ul></li>

<li><p><code>/spec-create &lt;app&gt; &quot;&lt;需求&gt;&quot;</code></p>

<ul>
<li>生成并持久化以下可审查工件（通常以 Markdown 文档形式保存，便于版本化与评审）：

<ul>
<li>PRD/规范：目标、用户故事、验收标准、非功能需求、边界条件。</li>
<li>技术实现计划：架构与模块设计、数据模型/接口契约、异常与错误处理策略、测试方案、部署与回滚策略。</li>
<li>任务清单：按可独立测试的粒度拆分的任务列表，带有依赖关系与验收要点。</li>
<li>命令脚本草案：为各任务生成建议的运行与验证命令（如 build/test/lint 等）。</li>
</ul></li>
<li>同步建立规范、计划与任务之间的追溯关系，确保每个技术决策都能回溯到明确需求。</li>
</ul></li>

<li><p><code>/spec-execute &lt;taskId&gt; &lt;app&gt;</code></p>

<ul>
<li>执行指定任务，生成对应的代码变更以及必要的测试用例草稿与运行步骤。</li>
<li>在 Claude Code 面板中呈现变更 diff 与命令输出，供审查、接受或回退；失败时给出问题诊断与下一步建议。</li>
<li>更新任务状态与相关文档的引用，维持“规范—计划—任务—代码”的闭环与一致性。</li>
</ul></li>
</ul>

<h2>APPENDIX. 参考</h2>

<ul>
<li>GitHub 博客：Spec-Driven Development 概览与工具包 — <a href="https://github.blog/ai-and-ml/generative-ai/spec-driven-development-with-ai-get-started-with-a-new-open-source-toolkit/" target="_blank">https://github.blog/ai-and-ml/generative-ai/spec-driven-development-with-ai-get-started-with-a-new-open-source-toolkit/</a></li>
<li>官方文档：Specification-Driven Development 详解 — <a href="https://github.com/github/spec-kit/blob/main/spec-driven.md" target="_blank">https://github.com/github/spec-kit/blob/main/spec-driven.md</a></li>
<li>GitHub 项目：Spec-Kit 开源工具集 — <a href="https://github.com/github/spec-kit" target="_blank">https://github.com/github/spec-kit</a></li>
<li>中文资源：Spec-Kit 中文版与文档 — <a href="https://github.com/888888888881/spec-kit-chinese" target="_blank">https://github.com/888888888881/spec-kit-chinese</a></li>
<li>项目仓库：Claude Code Spec Workflow — <a href="https://github.com/Pimzino/claude-code-spec-workflow" target="_blank">https://github.com/Pimzino/claude-code-spec-workflow</a></li>
<li>中文解读：Claude Code Spec Workflow 工作流介绍 — <a href="https://zhuanlan.zhihu.com/p/1948519805884805722" target="_blank">https://zhuanlan.zhihu.com/p/1948519805884805722</a></li>
</ul>
</div>
<script src="//vogo.github.io/markhtml/js/markhtml.js"></script>
</body>
</html>
