<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="//vogo.github.io/markhtml/css/markhtml.css">
    <title>Index</title>
</head>
<body class="markdown-body">
    <div id="navbar"></div>
    <div id="menu"></div>
    <div class="main" id="app">

<!--
markmeta_author: titlwind
markmeta_date: 2026-01-05
markmeta_title: AI 开发经验 2025
markmeta_categories: ai
markmeta_tags: ai,claude-code
-->

<h1>我的 AI 开发经验 2025</h1>

<h2>1. 基本认知</h2>

<p>现在是2025年刚结束, 来到2026年, 首先说明 <strong>当下</strong> 我对AI编码的一些基本认知。</p>

<ol>
<li>大语言模型通过训练海量数据，全知全能，但没有个性和偏好, 只有明确的问题才能得到明确的回答；</li>
<li>AI 编码工具本质上是一个Agent, 大模型能力和上下文工程能力决定了Agent的能力；</li>
<li>AI 编码能力（头部）已经非常强, 可以完成绝大多数任务，生成的代码质量已经非常高；</li>
<li>AI 生成的代码有问题, 大多是因为没有明确需求；</li>
<li>AI 没有生成符合偏好的代码, 也是因为没有明确偏好，比如更安全、更精简、更具扩展性等；</li>
<li>很难给 AI 提供极其精确的需求, 主要是人类需求是概括的、局部的、易变的、不明确的，人类很多时候是走一步看一步；</li>
</ol>

<p>所以 AI 开发要做的事情就是尽量明确好偏好和需求，AI便能极大的提升开发效率和质量。</p>

<blockquote>
<p>注: AI 已经让编程不再是工程师的专利, 而是变成了一个任何人都能用的工具。但目前要开发出一个生产级的系统，仍然需要有一定的工程能力。要开发一个高质量的系统，对人的综合性要求更高。</p>
</blockquote>

<h2>2. 基本思路</h2>

<p>从 原始需求 到 代码 有着巨大的鸿沟, 要想得到期望的产出，需要把握生成代码的方向不要偏离。</p>

<p>基本思路是：</p>

<ol>
<li><strong>提供给AI足够完整、清晰的背景知识</strong></li>
<li><strong>从原始需求到代码中间插入多个阶段中间产物，从中间产物生成下阶段的内容，并对每一个中间产物进行检查和纠偏。</strong></li>
</ol>

<pre><code class="language-mermaid">flowchart TD
    Requirement([原始需求]) --&gt; Process1(生成)
    Process1 --&gt; Artifact1[中间产物 1（如: 需求设计）]
    
    Artifact1 --&gt; Check1{检查 &amp; 纠偏}
    Check1 -- 不符合 --&gt; Artifact1
    Check1 -- 符合 --&gt; Process2(生成)
    
    Process2 --&gt; Artifact2[中间产物 2（例如: 技术设计）]
    
    Artifact2 --&gt; Check2{检查 &amp; 纠偏}
    Check2 -- 不符合 --&gt; Artifact2
    Check2 -- 符合 --&gt; Process3(生成)
    
    Process3 --&gt; Code[最终代码]
    
    Code --&gt; CheckCode{检查 &amp; 纠偏}
    CheckCode -- 不符合 --&gt; Code
    CheckCode -- 符合 --&gt; Finish([完成])
</code></pre>

<h2>3. 完整、清晰的背景知识</h2>

<p><strong>完整意味着包含所有必要的信息，清晰意味着信息之间没有冲突、没有歧义。</strong></p>

<p>背景知识包括：</p>

<ol>
<li>技术栈</li>
<li>架构和模式</li>
<li>模块结构</li>
<li>代码规范</li>
<li>原则</li>
<li>约定偏好</li>
</ol>

<p>有些信息是动态变化的，需要及时进行更新。</p>

<h2>4. 多阶段中间产物</h2>

<p>常见的中间产物：</p>

<pre><code>原始需求 --&gt; 架构设计 --&gt; 需求设计 --&gt; 技术设计 --&gt; 测试用例 --&gt; 代码
原始需求 --&gt; 架构设计 --&gt; 需求设计 --&gt; 技术设计 --&gt; 代码
原始需求 --&gt; 需求设计 --&gt; 技术设计 --&gt; Task List --&gt; 代码
原始需求 --&gt; 用户故事 --&gt; 技术设计 --&gt; 代码
原始需求 --&gt; 测试用例 --&gt; 代码
原始需求 --&gt; Spec --&gt; Plan --&gt; Task --&gt; 代码
原始需求 --&gt; Plan --&gt; 代码 
原始需求 --&gt; 代码（vibe coding）
</code></pre>

<p>基本逻辑：</p>

<ol>
<li><strong>足够小的需求（如方法级别）, 使用 vibe coding 即可；</strong></li>
<li><strong>原始需求越大，就越需要更多的中间产物来纠偏；</strong></li>
</ol>

<h2>5. Claude Code</h2>

<h3>5.1. Claude Code 背景知识</h3>

<p>通过项目根目录下的 <code>CLAUDE.md</code> 定义, 如果没有定义，可以通过 <code>/init</code> 命令让claude code 去分析代码生成，生成后做好做检查和修改。<strong>后续有新的规范性背景知识产生的时候，需要及时沉淀到 CLAUDE.md 中。</strong></p>

<h3>5.2. Claude Code 中间产物</h3>

<p>Claude Code 的中间产物就是 plan 计划内容, 通过 plan 模式生成执行计划，计划中实际上包含需求、设计、修改范围等信息, 已经能满足我绝大部分需求。plan 文件一般会存放在 <code>~/.claude/plans</code>.</p>

<p>Claude Code 生成的 plan（计划）通常包含以下几个主要部分：</p>

<ol>
<li><strong>任务理解 (Task Understanding)</strong>: 说明 Claude 对用户请求的理解，包括：要实现的核心功能，预期的输出结果，涉及的技术栈或工具</li>
<li><strong>当前状态分析 (Current State Analysis)</strong>: 评估项目的现有情况, 包括: 已存在的文件和代码结构,相关依赖或配置,需要修改的部分</li>
<li><strong>实施步骤 (Implementation Steps)</strong>: 详细的执行计划，通常按顺序列出：需要创建或修改的文件,每个步骤的具体操作,代码实现的逻辑顺序,可能需要的测试或验证步骤</li>
<li><strong>技术考虑 (Technical Considerations)</strong>: 说明实现过程中的技术决策， 包括：选择特定方案的原因,潜在的挑战或注意事项,最佳实践的应用</li>
<li><strong>验证方法 (Verification)</strong>: 如何确认任务完成， 包括：测试步骤,预期的输出或行为,可能的边界情况</li>
</ol>

<h2>6. SDD (Spec-Driven Development)</h2>

<p>规范驱动开发 (Spec-Driven Development, SDD) 是一种软件开发方法，首先需要创建一份详细、清晰且可执行的规范文档，这份文档定义了要构建什么以及为什么构建。然后，这份规范将驱动技术规划、任务分解和最终的代码实现。</p>

<blockquote>
<p>说明: 市面上包括 SpecKit、claude-code-spec-workflow等方案。</p>
</blockquote>

<p><code>SpecKit</code> 是 GitHub 推出的spec开源工具包，提供了一系列命令行工具和模板，与 Cursor、Claude Code、Gemini CLI 等 AI 编码工具深度集成。它包含四阶段核心工作流和一些辅助命令。</p>

<p><strong>定义背景知识</strong></p>

<ul>
<li><code>/speckit.constitution</code>: 定义项目的核心原则和开发规范，位于 <code>.specify/memory/constitution.md</code></li>
</ul>

<p><strong>核心工作流及中间产物</strong></p>

<ul>
<li><code>/speckit.specify</code>: 将功能需求转化为清晰的规范文档。</li>
<li><code>/speckit.plan</code>: 制定功能的技术实现方案。</li>
<li><code>/speckit.tasks</code>: 将技术方案分解为可执行的任务清单。</li>
<li><code>/speckit.implement</code>: 按任务清单逐步实现功能代码。</li>
</ul>

<p>每一个spec一个目录 <code>specs/123-xxx</code>, 形如:</p>

<pre><code>.
└── 001-chat-message-limit
    ├── checklists
    │   └── requirements.md
    ├── contracts
    │   └── chatting-api-changes.yml
    ├── data-model.md
    ├── IMPLEMENTATION_SUMMARY.md
    ├── plan.md
    ├── quickstart.md
    ├── research.md
    └── spec.md
</code></pre>

<p><strong>辅助命令</strong></p>

<ul>
<li><code>/speckit.clarify</code>: 解决规范中的模糊和歧义问题（可选, plan之前）</li>
<li><code>/speckit.checklist</code>: 生成需求质量验证清单（可选, plan之后）</li>
<li><code>/speckit.analyze</code>: 检查规范、计划、任务的一致性（可选, task之后, implement之前）</li>
</ul>

<h2>7. 使用 SDD 的感受</h2>

<p>目前的 SpecKit、claude-code-spec-workflow 等方案, 本质是一套软件工程实践的模板和工作流，通过标准化流程，减少AI编码过程中的错误和不一致性，提高开发效率和代码质量。</p>

<p>但是：</p>

<ul>
<li><code>费钱</code>: 每一个步骤都会按照模板进行完整分析, 按照 constitution 进行完整检查，消耗的Token也是成倍增加, specify、plan、task 阶段都触发了 claude code 限流；</li>
<li><code>费时</code>: 整个中间过程速度很慢，加上限流，一整天没有完成一个任务；</li>
<li><code>过于复杂审查困难</code>: 生成太多模板内容，太多细节，没办法一一阅读，审核起来太困难。</li>
<li><code>Spec仍然是中间产物</code>: 相关SDD的框架宣扬spec是代码蓝图是核心资产，代码只是下游附属产物。这个观点我是不认可的，spec仍然是中间产物，类似 git comment 一样的东西，可以用来追溯用，只能通过spec来了解项目演进过程，如果要了解项目全貌，从代码来得更直接。</li>
</ul>

<p>我想将 SDD 应用于大任务，但一个大任务有太多要考虑的细节，人的心智负担太大，很难完成审核，过程中存在很多返工的情况,就会逐渐失去耐心。</p>

<p>我觉得 SDD 比较有用的是 <code>/speckit.constitution</code> , 它定义了项目的核心原则和开发规范，可借助其完善 CLAUDE.md.</p>

<h2>8. 我的开发模式</h2>

<ol>
<li>定义并不断完善背景知识(CLAUDE.md)</li>
<li>人工拆分出的需求任务

<ol>
<li>模块级别 (一般是基础功能)</li>
<li>页面级别 (有完整的API定义)</li>
<li>API级别</li>
<li>单个功能级别</li>
</ol></li>
<li>整理需求</li>
<li>使用 plan 模式输出执行计划并审核修改</li>
<li>生成代码</li>
<li>微调</li>
</ol>

<p>需求内容要整理到什么程度呢？ 原则是：<strong>告诉AI足够的信息，不要让AI猜</strong>。</p>

<p>我的判断标准是问自己一个问题： <code>把 AI 当做一个能力很强的外包，已有项目背景知识 加上 告知他的需求内容, 是否足够让AI完成任务？</code> 如果我认为不够，则会尽量补充更多信息。</p>

<h2>9. 前端页面开发实践</h2>

<p>我得前端代码不熟悉，处于大概能看懂的程度。 AI 前端编码能力已经非常强大，如果对样式细节没有太大的要求，前端页面开发可以交给 AI 完成。</p>

<p>我的项目需要有一个后台管理系统，但缺少前端，基于以下考虑我决定用AI来开发：</p>

<ol>
<li>我对后台的样式没有特殊要求；</li>
<li>前端也不用考虑安全，全部交给后端处理；</li>
<li>后端 API 定义好后，AI 拥有比较完整的信息来创建页面；</li>
</ol>

<p>关于前端方案：</p>

<ol>
<li><code>采用非编译型页面</code>： 后台前端没有什么需要保密的，同时产生了问题，需要方便AI分析定位，直接部署AI生成的页面，所见即所得。</li>
<li><code>采用数据驱动型框架</code>： 数据驱动型框架让页面更简单灵活, 选择了熟悉的 Vue 3, Element Plus 来开发。</li>
<li><code>采用组件化开发</code>： 组件化开发让页面更易于维护和扩展，每个组件都有自己的状态和逻辑；</li>
</ol>

<p>前端项目结构:</p>

<pre><code>.
├── app.js
├── assets
│   └── css
│       ├── base.css
│       └── layout.css
├── index.html
├── layout
│   ├── AdminLayout.html
│   └── AdminLayout.js
├── router
│   └── index.js
├── singles
│   ├── agents.html
│   ├── centrifugo.html
│   └── index.css
├── store
│   └── index.js
├── utils
│   ├── apiUtils.js
│   ├── authUtils.js
│   ├── componentFactory.js
│   ├── cssLoader.js
│   ├── dateUtils.js
│   ├── keyvalue.js
│   └── templateLoader.js
└── views
    ├── activities
    │   ├── activity-reward
    │   │   ├── ActivityReward.css
    │   │   ├── ActivityReward.html
    │   │   └── ActivityReward.js
    │   └── activity-service-order
    │       ├── ActivityServiceOrder.css
    │       ├── ActivityServiceOrder.html
    │       └── ActivityServiceOrder.js
    ├── area
    │   ├── comhotreq
    │   │   ├── CommunityHotRequirementManagement.css
    │   │   ├── CommunityHotRequirementManagement.html
    │   │   └── CommunityHotRequirementManagement.js
    │   └── community
    │       ├── CommunityGeoFence.css
    │       ├── CommunityGeoFence.html
    │       └── CommunityGeoFence.js
</code></pre>

<p>开发一个新页面的提示词范本：</p>

<pre><code>请根据 xxxmapi.yml openapi 定义, 开发一个页面 static/views/&lt;group&gt;/&lt;module&gt;，包括功能 搜索、列表展示、详情、新增、编辑、删除。详情、新增、编辑、删除 分别点击按钮弹框进行操作。
</code></pre>

<p>页面修改提示词范本：</p>

<pre><code>请根据 /mapi/&lt;module&gt;/&lt;action&gt; openapi 定义, 修改 static/views/&lt;group&gt;/&lt;module&gt;，增加审核按钮，点击后弹窗进行审核，用户在页面选择 同意 或 拒绝， 输入审核理由， 二次确认收提交审核。
</code></pre>

<h2>10. Agent 自动化</h2>

<p>2025 年是 AI Agent 元年， Agent 已经融入到各行各业提升生产效率。</p>

<p>Claude Code 本身就是一个 Agent，除了用它来编码外，还可以用它来做一些自动化任务。</p>

<pre><code class="language-bash">claude --print --dangerously-skip-permissions &quot;$PROMPT&quot;
</code></pre>

<p>现在很多网站做了很多机制放置网页内容被抓取，让用户必须到网站才能查看。
但有了AI，可以模拟用户行为，去抓取网页内容并分析。
我就可以用 cladue code 去做一个定时任务，定时去抓去网页内容并分析，获取最新内容，推送给我。</p>

<p>可以给calude code 安装上 mcp, skills 等插件，扩展他的能力。
只要敢于想象，AI 可以做的事情远不止于此。</p>

<p>推荐一些MCP:</p>

<ul>
<li>chrome-devtools-mcp: 控制和检查 Chrome 浏览器</li>
<li>github: GitHub 仓库操作 (Issue, PR, Commit)</li>
<li>postgres: PostgreSQL 数据库操作</li>
<li>sqlite: 数据库操作</li>
</ul>

<p>官方 Skills:</p>

<ul>
<li><strong>document-skills</strong>: 文档处理核心能力 (Word, Excel, PPT, PDF)</li>
<li><strong>agent-sdk-dev</strong>: Agent SDK 开发工具包</li>
</ul>

<p>社区精选 Skills:</p>

<ul>
<li><strong>ui-designer</strong>: UI/UX 设计专家，快速构建设计系统</li>
</ul>

<h2>11. 对未来AI的展望</h2>

<p>现在 AI 编码能力已经非常强大，但仍然要人参与。</p>

<p>我个人认为还有很多背景知识还没有提供给到AI:</p>

<ul>
<li>公司战略、业务情况、财务状况、团队情况；</li>
<li>市场行情、竞争情况、客户需求；</li>
<li>开发者说不清道不明的个人经验；</li>
</ul>

<p>总之，有些东西貌似和编码没关，缺潜在AI编码时候的一些决策。
如果AI拥有像人一下的上下文，随着AI的进步，就能够像人一样，产出服务目标的功能。</p>
</div>
<script src="//vogo.github.io/markhtml/js/markhtml.js"></script>
</body>
</html>
