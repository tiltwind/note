<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="//vogo.github.io/markhtml/css/markhtml.css">
    <title>Index</title>
</head>
<body class="markdown-body">
    <div id="navbar"></div>
    <div id="menu"></div>
    <div class="main" id="app">

<!---
markmeta_author: tiltwind
markmeta_date: 2025-12-09
markmeta_title: Rust å…¥é—¨
markmeta_categories: ç¼–ç¨‹è¯­è¨€
markmeta_tags: rust
-->

<h1>Rust å…¥é—¨</h1>

<p><strong>æ‘˜è¦</strong>:
æœ¬æ–‡ç®€è¦ä»‹ç»äº†Rustè¯­è¨€çš„å‘å±•å†å²ï¼Œé€šè¿‡æ–‡å­—å’Œæºä»£ç å½¢å¼ä»‹ç»Rustè¯­è¨€åŸºæœ¬è¯­æ³•ã€å¼€å‘å·¥å…·ã€æ‰€æœ‰æƒæ¨¡å‹ã€å¹¶å‘ç¼–ç¨‹ç­‰ã€‚
æœ¬æ–‡ä½œä¸ºRustè¯­è¨€çš„å…¥é—¨èµ„æ–™ï¼Œè¯»è€…å¯ä»¥é€šè¿‡æœ¬æ–‡å¿«é€Ÿäº†è§£Rustè¯­è¨€çš„åŸºæœ¬ç”¨æ³•ã€‚</p>

<h2>1. Rust ä»‹ç»</h2>

<p>Rust æ˜¯ä¸€é—¨ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ï¼Œä¸“æ³¨äºå®‰å…¨ã€å¹¶å‘å’Œæ€§èƒ½ã€‚å®ƒç”± Mozilla ç ”ç©¶å‘˜ Graydon Hoare äº 2006 å¹´ä½œä¸ºä¸ªäººé¡¹ç›®å¼€å§‹å¼€å‘ã€‚</p>

<h3>1.1. å‘å±•å†å²</h3>

<ul>
<li>2006å¹´ï¼ŒGraydon Hoare å¼€å§‹è®¾è®¡ Rust è¯­è¨€</li>
<li>2009å¹´ï¼ŒMozilla å¼€å§‹èµåŠ©è¯¥é¡¹ç›®</li>
<li>2010å¹´ï¼ŒRust é¦–æ¬¡å…¬å¼€å‘å¸ƒ</li>
<li>2015å¹´5æœˆ15æ—¥ï¼Œå‘å¸ƒ Rust 1.0 ç¨³å®šç‰ˆ</li>
<li>2018å¹´ï¼ŒRust 2018 Edition å‘å¸ƒï¼Œå¼•å…¥äº†è®¸å¤šæ–°ç‰¹æ€§</li>
<li>2021å¹´ï¼ŒRust 2021 Edition å‘å¸ƒ</li>
<li>2021å¹´2æœˆï¼ŒRust åŸºé‡‘ä¼šæˆç«‹ï¼Œç”± AWSã€åä¸ºã€è°·æ­Œã€å¾®è½¯å’Œ Mozilla è”åˆåˆ›ç«‹</li>
<li>2024å¹´ï¼ŒRust 2024 Edition å‘å¸ƒ</li>
</ul>

<h3>1.2. Rust çš„ç‰¹ç‚¹</h3>

<p>Rust çš„è®¾è®¡ç›®æ ‡æ˜¯æä¾›å†…å­˜å®‰å…¨ã€å¹¶å‘å®‰å…¨å’Œé«˜æ€§èƒ½ï¼š</p>

<p><strong>å†…å­˜å®‰å…¨</strong>ï¼š</p>

<ul>
<li>æ— éœ€åƒåœ¾å›æ”¶å™¨(GC)å³å¯ä¿è¯å†…å­˜å®‰å…¨</li>
<li>é€šè¿‡æ‰€æœ‰æƒ(Ownership)ç³»ç»Ÿåœ¨ç¼–è¯‘æ—¶é˜²æ­¢å†…å­˜é”™è¯¯</li>
<li>é¿å…ç©ºæŒ‡é’ˆã€æ‚¬å‚æŒ‡é’ˆã€æ•°æ®ç«äº‰ç­‰å¸¸è§é”™è¯¯</li>
</ul>

<p><strong>é›¶æˆæœ¬æŠ½è±¡</strong>ï¼š</p>

<ul>
<li>é«˜çº§æŠ½è±¡ä¸ä¼šå¸¦æ¥è¿è¡Œæ—¶å¼€é”€</li>
<li>æ€§èƒ½å¯ä»¥åª²ç¾ C/C++</li>
</ul>

<p><strong>å¹¶å‘å®‰å…¨</strong>ï¼š</p>

<ul>
<li>ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥å¹¶å‘ä»£ç çš„å®‰å…¨æ€§</li>
<li>é˜²æ­¢æ•°æ®ç«äº‰</li>
</ul>

<p><strong>å®ç”¨æ€§</strong>ï¼š</p>

<ul>
<li>ä¼˜ç§€çš„åŒ…ç®¡ç†å™¨ Cargo</li>
<li>å‹å¥½çš„ç¼–è¯‘å™¨é”™è¯¯ä¿¡æ¯</li>
<li>å®Œå–„çš„æ–‡æ¡£å’Œå·¥å…·é“¾</li>
<li>å¼ºå¤§çš„ç±»å‹ç³»ç»Ÿå’Œæ¨¡å¼åŒ¹é…</li>
</ul>

<p>Rust è¢«å¹¿æ³›åº”ç”¨äºï¼š</p>

<ul>
<li>ç³»ç»Ÿç¼–ç¨‹ï¼šæ“ä½œç³»ç»Ÿã€è®¾å¤‡é©±åŠ¨</li>
<li>Web æœåŠ¡ï¼šé«˜æ€§èƒ½åç«¯æœåŠ¡</li>
<li>å‘½ä»¤è¡Œå·¥å…·ï¼šripgrepã€fdã€bat ç­‰</li>
<li>WebAssemblyï¼šå‰ç«¯æ€§èƒ½å…³é”®ä»£ç </li>
<li>åµŒå…¥å¼å¼€å‘ï¼šIoT è®¾å¤‡</li>
<li>åŒºå—é“¾ï¼šPolkadotã€Solana ç­‰</li>
</ul>

<p><img src="images/rust-logo.png" alt="" /></p>

<blockquote>
<p>Rust çš„å‰ç¥¥ç‰©æ˜¯ä¸€åªåä¸º Ferris çš„èƒèŸ¹ã€‚</p>
</blockquote>

<p>å‚è€ƒ:</p>

<ol>
<li><a href="https://www.rust-lang.org/" target="_blank">Rust å®˜ç½‘</a></li>
<li><a href="https://doc.rust-lang.org/book/" target="_blank">The Rust Programming Language Book</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Rust" target="_blank">Rust Wikipedia</a></li>
</ol>

<h2>2. Rust å®‰è£…</h2>

<h3>2.1. ä½¿ç”¨ rustup å®‰è£…</h3>

<p>rustup æ˜¯ Rust çš„å®˜æ–¹å®‰è£…å™¨å’Œç‰ˆæœ¬ç®¡ç†å·¥å…·ã€‚</p>

<p>Mac/Linux å®‰è£…:</p>

<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# é…ç½®ç¯å¢ƒå˜é‡ï¼ˆå®‰è£…ç¨‹åºä¼šè‡ªåŠ¨æ·»åŠ åˆ° shell é…ç½®æ–‡ä»¶ï¼‰
source $HOME/.cargo/env
</code></pre>

<p>Windows å®‰è£…:</p>

<ul>
<li>è®¿é—® <a href="https://rustup.rs/" target="_blank">https://rustup.rs/</a> ä¸‹è½½ rustup-init.exe å¹¶è¿è¡Œ</li>
<li>æˆ–ä½¿ç”¨ winget: <code>winget install Rustlang.Rustup</code></li>
</ul>

<p>éªŒè¯å®‰è£…:</p>

<pre><code class="language-bash">rustc --version
# rustc 1.75.0 (82e1608df 2023-12-21)

cargo --version
# cargo 1.75.0 (1d8b05cdd 2023-11-20)
</code></pre>

<h3>2.2. æ›´æ–°å’Œå¸è½½</h3>

<pre><code class="language-bash"># æ›´æ–° Rust
rustup update

# æŸ¥çœ‹å·²å®‰è£…çš„å·¥å…·é“¾
rustup show

# å¸è½½ Rust
rustup self uninstall
</code></pre>

<h3>2.3. é…ç½®å›½å†…é•œåƒæº</h3>

<p>åˆ›å»ºæˆ–ç¼–è¾‘ <code>~/.cargo/config</code> æ–‡ä»¶:</p>

<pre><code class="language-bash">mkdir -p ~/.cargo
cat &gt; ~/.cargo/config &lt;&lt; 'EOF'
[source.crates-io]
replace-with = 'tuna'

[source.tuna]
registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;
EOF
</code></pre>

<p>æˆ–ä½¿ç”¨å­—èŠ‚è·³åŠ¨çš„é•œåƒ:</p>

<pre><code class="language-toml">[source.crates-io]
replace-with = 'rsproxy'

[source.rsproxy]
registry = &quot;https://rsproxy.cn/crates.io-index&quot;
</code></pre>

<h3>2.4. Rust å·¥å…·é“¾</h3>

<p>Rust å·¥å…·é“¾åŒ…å«ï¼š</p>

<ul>
<li><strong>rustc</strong>: Rust ç¼–è¯‘å™¨</li>
<li><strong>cargo</strong>: åŒ…ç®¡ç†å™¨å’Œæ„å»ºå·¥å…·</li>
<li><strong>rustup</strong>: å·¥å…·é“¾ç®¡ç†å™¨</li>
<li><strong>rustfmt</strong>: ä»£ç æ ¼å¼åŒ–å·¥å…·</li>
<li><strong>clippy</strong>: ä»£ç æ£€æŸ¥å·¥å…·</li>
<li><strong>rust-analyzer</strong>: LSP è¯­è¨€æœåŠ¡å™¨ï¼ˆIDE æ”¯æŒï¼‰</li>
</ul>

<p>å®‰è£…é¢å¤–å·¥å…·:</p>

<pre><code class="language-bash"># å®‰è£… rustfmt å’Œ clippy
rustup component add rustfmt clippy

# å®‰è£… rust-analyzer
rustup component add rust-analyzer
</code></pre>

<h2>3. Hello World èŒƒä¾‹</h2>

<p>åˆ›å»ºæ–°é¡¹ç›®:</p>

<pre><code class="language-bash">cargo new hello_world
cd hello_world
</code></pre>

<p>é¡¹ç›®ç»“æ„:</p>

<pre><code>hello_world/
â”œâ”€â”€ Cargo.toml    # é¡¹ç›®é…ç½®æ–‡ä»¶
â””â”€â”€ src/
    â””â”€â”€ main.rs   # æºä»£ç 
</code></pre>

<p><code>src/main.rs</code>:</p>

<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>

<p>ç¼–è¯‘å¹¶è¿è¡Œ:</p>

<pre><code class="language-bash"># ç¼–è¯‘å¹¶è¿è¡Œ
cargo run
# Hello, world!

# åªç¼–è¯‘
cargo build
# ç¼–è¯‘ç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶åœ¨ target/debug/hello_world

# å‘å¸ƒç‰ˆæœ¬ç¼–è¯‘ï¼ˆå¼€å¯ä¼˜åŒ–ï¼‰
cargo build --release
# ç”Ÿæˆæ–‡ä»¶åœ¨ target/release/hello_world

# æ£€æŸ¥ä»£ç æ˜¯å¦èƒ½ç¼–è¯‘ï¼ˆä¸ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ï¼Œé€Ÿåº¦æ›´å¿«ï¼‰
cargo check
</code></pre>

<p>ç›´æ¥ä½¿ç”¨ rustc ç¼–è¯‘:</p>

<pre><code class="language-bash"># åˆ›å»ºå•æ–‡ä»¶
echo 'fn main() { println!(&quot;Hello, world!&quot;); }' &gt; hello.rs

# ç¼–è¯‘
rustc hello.rs

# è¿è¡Œ
./hello
# Hello, world!
</code></pre>

<h2>4. Rust å…³é”®å­—</h2>

<p>Rust æœ‰ <strong>53 ä¸ªå…³é”®å­—</strong>ï¼Œåˆ†ä¸ºä¸¥æ ¼å…³é”®å­—å’Œä¿ç•™å…³é”®å­—ã€‚</p>

<p><strong>ä¸¥æ ¼å…³é”®å­—</strong>ï¼ˆå·²è¢«ä½¿ç”¨ï¼‰:</p>

<pre><code>as          break       const       continue    crate
else        enum        extern      false       fn
for         if          impl        in          let
loop        match       mod         move        mut
pub         ref         return      self        Self
static      struct      super       trait       true
type        unsafe      use         where       while
async       await       dyn
</code></pre>

<p><strong>ä¿ç•™å…³é”®å­—</strong>ï¼ˆä¿ç•™ä¾›æœªæ¥ä½¿ç”¨ï¼‰:</p>

<pre><code>abstract    become      box         do          final
macro       override    priv        try         typeof
unsized     virtual     yield
</code></pre>

<p><strong>åŸå§‹æ ‡è¯†ç¬¦</strong>: å¦‚æœéœ€è¦ä½¿ç”¨å…³é”®å­—ä½œä¸ºæ ‡è¯†ç¬¦ï¼Œå¯ä»¥ä½¿ç”¨ <code>r#</code> å‰ç¼€ï¼š</p>

<pre><code class="language-rust">let r#match = &quot;match&quot;; // ä½¿ç”¨ match å…³é”®å­—ä½œä¸ºå˜é‡å
</code></pre>

<h2>5. Rust ç±»å‹</h2>

<h3>5.1. æ ‡é‡ç±»å‹</h3>

<p><strong>æ•´æ•°ç±»å‹</strong>:</p>

<table>
<thead>
<tr>
<th>é•¿åº¦</th>
<th>æœ‰ç¬¦å·</th>
<th>æ— ç¬¦å·</th>
</tr>
</thead>

<tbody>
<tr>
<td>8-bit</td>
<td>i8</td>
<td>u8</td>
</tr>

<tr>
<td>16-bit</td>
<td>i16</td>
<td>u16</td>
</tr>

<tr>
<td>32-bit</td>
<td>i32</td>
<td>u32</td>
</tr>

<tr>
<td>64-bit</td>
<td>i64</td>
<td>u64</td>
</tr>

<tr>
<td>128-bit</td>
<td>i128</td>
<td>u128</td>
</tr>

<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody>
</table>

<pre><code class="language-rust">let x: i32 = 42;
let y: u64 = 100;
let z = 98_222;        // ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†éš”ï¼Œæé«˜å¯è¯»æ€§
let hex = 0xff;        // åå…­è¿›åˆ¶
let octal = 0o77;      // å…«è¿›åˆ¶
let binary = 0b1111_0000; // äºŒè¿›åˆ¶
let byte = b'A';       // å­—èŠ‚ï¼ˆä»…é™ u8ï¼‰
</code></pre>

<p><strong>æµ®ç‚¹ç±»å‹</strong>:</p>

<pre><code class="language-rust">let x: f32 = 2.0;      // f32
let y: f64 = 3.0;      // f64ï¼ˆé»˜è®¤ç±»å‹ï¼‰
</code></pre>

<p><strong>å¸ƒå°”ç±»å‹</strong>:</p>

<pre><code class="language-rust">let t: bool = true;
let f: bool = false;
</code></pre>

<p><strong>å­—ç¬¦ç±»å‹</strong>:</p>

<pre><code class="language-rust">let c: char = 'z';
let emoji: char = 'ğŸ˜»';  // char æ˜¯ 4 å­—èŠ‚ Unicode æ ‡é‡å€¼
</code></pre>

<h3>5.2. å¤åˆç±»å‹</h3>

<p><strong>å…ƒç»„ (Tuple)</strong>:</p>

<pre><code class="language-rust">let tup: (i32, f64, u8) = (500, 6.4, 1);

// è§£æ„
let (x, y, z) = tup;
println!(&quot;y = {}&quot;, y);

// ç´¢å¼•è®¿é—®
let five_hundred = tup.0;
let six_point_four = tup.1;
</code></pre>

<p><strong>æ•°ç»„ (Array)</strong>:</p>

<pre><code class="language-rust">let a: [i32; 5] = [1, 2, 3, 4, 5];  // å›ºå®šé•¿åº¦
let first = a[0];
let second = a[1];

// åˆå§‹åŒ–ç›¸åŒå€¼
let a = [3; 5];  // [3, 3, 3, 3, 3]
</code></pre>

<p><strong>åˆ‡ç‰‡ (Slice)</strong>:</p>

<pre><code class="language-rust">let a = [1, 2, 3, 4, 5];
let slice = &amp;a[1..3];  // [2, 3]
</code></pre>

<h2>6. Rust å˜é‡</h2>

<h3>6.1. å˜é‡å£°æ˜</h3>

<pre><code class="language-rust">fn main() {
    // ä¸å¯å˜å˜é‡ï¼ˆé»˜è®¤ï¼‰
    let x = 5;
    // x = 6;  // é”™è¯¯ï¼ä¸èƒ½ä¿®æ”¹ä¸å¯å˜å˜é‡

    // å¯å˜å˜é‡
    let mut y = 5;
    println!(&quot;y = {}&quot;, y);
    y = 6;
    println!(&quot;y = {}&quot;, y);

    // å¸¸é‡ï¼ˆå¿…é¡»æ ‡æ³¨ç±»å‹ï¼Œä½¿ç”¨å¤§å†™å­—æ¯å’Œä¸‹åˆ’çº¿ï¼‰
    const MAX_POINTS: u32 = 100_000;
}
</code></pre>

<h3>6.2. é®è”½ (Shadowing)</h3>

<pre><code class="language-rust">let x = 5;
let x = x + 1;    // é®è”½å‰ä¸€ä¸ª x
let x = x * 2;    // å†æ¬¡é®è”½
println!(&quot;x = {}&quot;, x);  // 12

// å¯ä»¥æ”¹å˜ç±»å‹
let spaces = &quot;   &quot;;
let spaces = spaces.len();  // ä» &amp;str å˜ä¸º usize
</code></pre>

<h3>6.3. ç±»å‹æ¨æ–­å’Œæ˜¾å¼ç±»å‹</h3>

<pre><code class="language-rust">let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);  // é”™è¯¯ï¼æ— æ³•æ¨æ–­ç±»å‹

let guess: i32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);  // æ­£ç¡®

// ä½¿ç”¨ turbofish è¯­æ³•
let guess = &quot;42&quot;.parse::&lt;i32&gt;().expect(&quot;Not a number!&quot;);
</code></pre>

<h2>7. æ§åˆ¶æµ</h2>

<h3>7.1. if è¡¨è¾¾å¼</h3>

<pre><code class="language-rust">let number = 6;

if number % 4 == 0 {
    println!(&quot;èƒ½è¢« 4 æ•´é™¤&quot;);
} else if number % 3 == 0 {
    println!(&quot;èƒ½è¢« 3 æ•´é™¤&quot;);
} else {
    println!(&quot;ä¸èƒ½è¢« 4 æˆ– 3 æ•´é™¤&quot;);
}

// if æ˜¯è¡¨è¾¾å¼ï¼Œå¯ä»¥èµ‹å€¼
let condition = true;
let number = if condition { 5 } else { 6 };
</code></pre>

<h3>7.2. loop å¾ªç¯</h3>

<pre><code class="language-rust">// æ— é™å¾ªç¯
loop {
    println!(&quot;again!&quot;);
    break;  // é€€å‡ºå¾ªç¯
}

// ä»å¾ªç¯è¿”å›å€¼
let mut counter = 0;
let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2;  // è¿”å›å€¼
    }
};
println!(&quot;ç»“æœï¼š{}&quot;, result);  // 20

// å¾ªç¯æ ‡ç­¾
'outer: loop {
    loop {
        break 'outer;  // è·³å‡ºå¤–å±‚å¾ªç¯
    }
}
</code></pre>

<h3>7.3. while å¾ªç¯</h3>

<pre><code class="language-rust">let mut number = 3;

while number != 0 {
    println!(&quot;{}!&quot;, number);
    number -= 1;
}
println!(&quot;LIFTOFF!!!&quot;);
</code></pre>

<h3>7.4. for å¾ªç¯</h3>

<pre><code class="language-rust">// éå†æ•°ç»„
let a = [10, 20, 30, 40, 50];
for element in a {
    println!(&quot;å€¼ï¼š{}&quot;, element);
}

// Range
for number in 1..4 {  // ä¸åŒ…å« 4
    println!(&quot;{}&quot;, number);
}

for number in 1..=4 {  // åŒ…å« 4
    println!(&quot;{}&quot;, number);
}

// å€’åº
for number in (1..4).rev() {
    println!(&quot;{}&quot;, number);
}

// å¸¦ç´¢å¼•
for (index, value) in a.iter().enumerate() {
    println!(&quot;ç´¢å¼• {} çš„å€¼æ˜¯ {}&quot;, index, value);
}
</code></pre>

<h3>7.5. match è¡¨è¾¾å¼</h3>

<pre><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}

// å¸¦ç»‘å®šçš„æ¨¡å¼
match some_value {
    Some(x) =&gt; println!(&quot;å€¼ï¼š{}&quot;, x),
    None =&gt; println!(&quot;æ²¡æœ‰å€¼&quot;),
}

// é€šé…ç¬¦
let dice_roll = 9;
match dice_roll {
    3 =&gt; println!(&quot;ç‰¹æ®Šå€¼ 3&quot;),
    7 =&gt; println!(&quot;ç‰¹æ®Šå€¼ 7&quot;),
    _ =&gt; println!(&quot;å…¶ä»–å€¼&quot;),  // _ åŒ¹é…æ‰€æœ‰å…¶ä»–æƒ…å†µ
}
</code></pre>

<h3>7.6. if let ç®€åŒ–è¯­æ³•</h3>

<pre><code class="language-rust">let some_value = Some(3);

// ä½¿ç”¨ match
match some_value {
    Some(3) =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
}

// ä½¿ç”¨ if let
if let Some(3) = some_value {
    println!(&quot;three&quot;);
}
</code></pre>

<h2>8. æ‰€æœ‰æƒ (Ownership)</h2>

<p>æ‰€æœ‰æƒæ˜¯ Rust æœ€ç‹¬ç‰¹çš„ç‰¹æ€§ï¼Œä½¿å¾— Rust æ— éœ€åƒåœ¾å›æ”¶å™¨å³å¯ä¿è¯å†…å­˜å®‰å…¨ã€‚</p>

<h3>8.1. æ‰€æœ‰æƒè§„åˆ™</h3>

<ol>
<li>Rust ä¸­çš„æ¯ä¸€ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªè¢«ç§°ä¸ºå…¶<strong>æ‰€æœ‰è€…</strong>(owner)çš„å˜é‡</li>
<li>å€¼åœ¨ä»»ä¸€æ—¶åˆ»æœ‰ä¸”åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…</li>
<li>å½“æ‰€æœ‰è€…ï¼ˆå˜é‡ï¼‰ç¦»å¼€ä½œç”¨åŸŸï¼Œè¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒ</li>
</ol>

<h3>8.2. ç§»åŠ¨è¯­ä¹‰</h3>

<pre><code class="language-rust">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;  // s1 çš„æ‰€æœ‰æƒç§»åŠ¨åˆ° s2

// println!(&quot;{}&quot;, s1);  // é”™è¯¯ï¼s1 å·²å¤±æ•ˆ
println!(&quot;{}&quot;, s2);  // æ­£ç¡®
</code></pre>

<h3>8.3. å…‹éš†</h3>

<pre><code class="language-rust">let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();  // æ·±æ‹·è´

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);  // éƒ½æœ‰æ•ˆ
</code></pre>

<h3>8.4. Copy trait</h3>

<p>æ ˆä¸Šçš„ç®€å•ç±»å‹å®ç°äº† Copy traitï¼Œèµ‹å€¼æ—¶ä¼šè‡ªåŠ¨å¤åˆ¶ï¼š</p>

<pre><code class="language-rust">let x = 5;
let y = x;  // x è¢«å¤åˆ¶

println!(&quot;x = {}, y = {}&quot;, x, y);  // éƒ½æœ‰æ•ˆ
</code></pre>

<p>å®ç° Copy çš„ç±»å‹ï¼š</p>

<ul>
<li>æ‰€æœ‰æ•´æ•°ç±»å‹</li>
<li>å¸ƒå°”ç±»å‹</li>
<li>æ‰€æœ‰æµ®ç‚¹ç±»å‹</li>
<li>å­—ç¬¦ç±»å‹</li>
<li>å…ƒç»„ï¼ˆä»…å½“å…¶åŒ…å«çš„ç±»å‹ä¹Ÿéƒ½å®ç° Copy æ—¶ï¼‰</li>
</ul>

<h3>8.5. å¼•ç”¨å’Œå€Ÿç”¨</h3>

<pre><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let len = calculate_length(&amp;s1);  // å€Ÿç”¨
    println!(&quot;'{}' çš„é•¿åº¦æ˜¯ {}&quot;, s1, len);  // s1 ä»ç„¶æœ‰æ•ˆ
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}  // s ç¦»å¼€ä½œç”¨åŸŸï¼Œä½†å› ä¸ºå®ƒæ²¡æœ‰æ‰€æœ‰æƒï¼Œæ‰€ä»¥ä¸ä¼šé‡Šæ”¾
</code></pre>

<h3>8.6. å¯å˜å¼•ç”¨</h3>

<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    change(&amp;mut s);
    println!(&quot;{}&quot;, s);  // hello, world
}

fn change(s: &amp;mut String) {
    s.push_str(&quot;, world&quot;);
}
</code></pre>

<p><strong>å¯å˜å¼•ç”¨çš„é™åˆ¶</strong>ï¼š</p>

<ol>
<li>åŒä¸€ä½œç”¨åŸŸä¸­ï¼Œç‰¹å®šæ•°æ®åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨</li>
<li>ä¸èƒ½åŒæ—¶æ‹¥æœ‰å¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨</li>
</ol>

<pre><code class="language-rust">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s;      // æ²¡é—®é¢˜
let r2 = &amp;s;      // æ²¡é—®é¢˜
// let r3 = &amp;mut s;  // é”™è¯¯ï¼ä¸èƒ½åŒæ—¶æœ‰ä¸å¯å˜å’Œå¯å˜å¼•ç”¨

println!(&quot;{} and {}&quot;, r1, r2);
// r1 å’Œ r2 çš„ä½œç”¨åŸŸåˆ°æ­¤ç»“æŸ

let r3 = &amp;mut s;  // ç°åœ¨æ²¡é—®é¢˜
</code></pre>

<h3>8.7. æ‚¬å‚å¼•ç”¨</h3>

<p>Rust ç¼–è¯‘å™¨ä¿è¯å¼•ç”¨æ°¸è¿œä¸ä¼šæˆä¸ºæ‚¬å‚å¼•ç”¨ï¼š</p>

<pre><code class="language-rust">fn dangle() -&gt; &amp;String {  // é”™è¯¯ï¼
    let s = String::from(&quot;hello&quot;);
    &amp;s  // è¿”å› s çš„å¼•ç”¨
}  // s ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒï¼Œå…¶å†…å­˜è¢«é‡Šæ”¾

// æ­£ç¡®åšæ³•ï¼šè¿”å›æ‰€æœ‰æƒ
fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);
    s  // è¿”å› sï¼Œæ‰€æœ‰æƒè¢«ç§»å‡º
}
</code></pre>

<h2>9. ç»“æ„ä½“ (Struct)</h2>

<h3>9.1. å®šä¹‰å’Œå®ä¾‹åŒ–</h3>

<pre><code class="language-rust">struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let mut user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;anotheremail@example.com&quot;);
}
</code></pre>

<h3>9.2. å­—æ®µåˆå§‹åŒ–ç®€å†™</h3>

<pre><code class="language-rust">fn build_user(email: String, username: String) -&gt; User {
    User {
        email,     // ç®€å†™
        username,  // ç®€å†™
        active: true,
        sign_in_count: 1,
    }
}
</code></pre>

<h3>9.3. ç»“æ„ä½“æ›´æ–°è¯­æ³•</h3>

<pre><code class="language-rust">let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    ..user1  // å…¶ä½™å­—æ®µä½¿ç”¨ user1 çš„å€¼
};
</code></pre>

<h3>9.4. å…ƒç»„ç»“æ„ä½“</h3>

<pre><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
</code></pre>

<h3>9.5. æ–¹æ³•</h3>

<pre><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // æ–¹æ³•
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }

    // å…³è”å‡½æ•°ï¼ˆç±»ä¼¼é™æ€æ–¹æ³•ï¼‰
    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;é¢ç§¯ï¼š{}&quot;, rect1.area());

    let sq = Rectangle::square(3);
}
</code></pre>

<h2>10. æšä¸¾ (Enum)</h2>

<h3>10.1. å®šä¹‰æšä¸¾</h3>

<pre><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}

let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
</code></pre>

<h3>10.2. æšä¸¾å€¼</h3>

<pre><code class="language-rust">enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
</code></pre>

<h3>10.3. Option æšä¸¾</h3>

<pre><code class="language-rust">enum Option&lt;T&gt; {
    Some(T),
    None,
}

let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);
let absent_number: Option&lt;i32&gt; = None;
</code></pre>

<h3>10.4. æšä¸¾æ–¹æ³•</h3>

<pre><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&amp;self) {
        // æ–¹æ³•ä½“
    }
}

let m = Message::Write(String::from(&quot;hello&quot;));
m.call();
</code></pre>

<h2>11. æ³›å‹ (Generics)</h2>

<h3>11.1. æ³›å‹å‡½æ•°</h3>

<pre><code class="language-rust">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];
    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest(&amp;number_list);
    println!(&quot;æœ€å¤§å€¼ï¼š{}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest(&amp;char_list);
    println!(&quot;æœ€å¤§å€¼ï¼š{}&quot;, result);
}
</code></pre>

<h3>11.2. æ³›å‹ç»“æ„ä½“</h3>

<pre><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

// åªä¸ºç‰¹å®šç±»å‹å®ç°æ–¹æ³•
impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
</code></pre>

<h3>11.3. æ³›å‹æšä¸¾</h3>

<pre><code class="language-rust">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>

<h2>12. Trait</h2>

<p>Trait ç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„æ¥å£ã€‚</p>

<h3>12.1. å®šä¹‰ Trait</h3>

<pre><code class="language-rust">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;

    // é»˜è®¤å®ç°
    fn summarize_author(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
</code></pre>

<h3>12.2. å®ç° Trait</h3>

<pre><code class="language-rust">pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
</code></pre>

<h3>12.3. Trait ä½œä¸ºå‚æ•°</h3>

<pre><code class="language-rust">pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}

// Trait Bound è¯­æ³•
pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}

// å¤šä¸ª Trait Bound
pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
    // ...
}

// where å­å¥
fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
    // ...
}
</code></pre>

<h3>12.4. è¿”å›å®ç° Trait çš„ç±»å‹</h3>

<pre><code class="language-rust">fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;of course, as you probably already know, people&quot;),
        reply: false,
        retweet: false,
    }
}
</code></pre>

<h3>12.5. å¸¸ç”¨ Trait</h3>

<pre><code class="language-rust">// Debug - æ ¼å¼åŒ–æ‰“å°
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

// Clone - å…‹éš†
#[derive(Clone)]
struct MyStruct;

// Copy - å¤åˆ¶
#[derive(Copy, Clone)]
struct MySmallStruct;

// PartialEq, Eq - ç›¸ç­‰æ¯”è¾ƒ
#[derive(PartialEq, Eq)]
struct Coordinate {
    x: i32,
    y: i32,
}
</code></pre>

<h2>13. é”™è¯¯å¤„ç†</h2>

<h3>13.1. panic! å®</h3>

<pre><code class="language-rust">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre>

<h3>13.2. Result æšä¸¾</h3>

<pre><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;æ‰“å¼€æ–‡ä»¶å‡ºé”™ï¼š{:?}&quot;, error),
    };
}
</code></pre>

<h3>13.3. ? è¿ç®—ç¬¦</h3>

<pre><code class="language-rust">use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}

// é“¾å¼è°ƒç”¨
fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();
    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;
    Ok(s)
}
</code></pre>

<h3>13.4. unwrap å’Œ expect</h3>

<pre><code class="language-rust">let f = File::open(&quot;hello.txt&quot;).unwrap();

let f = File::open(&quot;hello.txt&quot;)
    .expect(&quot;æ— æ³•æ‰“å¼€ hello.txt&quot;);
</code></pre>

<h2>14. é›†åˆç±»å‹</h2>

<h3>14.1. Vector</h3>

<pre><code class="language-rust">// åˆ›å»º vector
let v: Vec&lt;i32&gt; = Vec::new();
let v = vec![1, 2, 3];

// æ·»åŠ å…ƒç´ 
let mut v = Vec::new();
v.push(5);
v.push(6);
v.push(7);

// è¯»å–å…ƒç´ 
let v = vec![1, 2, 3, 4, 5];
let third: &amp;i32 = &amp;v[2];
println!(&quot;ç¬¬ä¸‰ä¸ªå…ƒç´ ï¼š{}&quot;, third);

match v.get(2) {
    Some(third) =&gt; println!(&quot;ç¬¬ä¸‰ä¸ªå…ƒç´ ï¼š{}&quot;, third),
    None =&gt; println!(&quot;æ²¡æœ‰ç¬¬ä¸‰ä¸ªå…ƒç´ &quot;),
}

// éå†
let v = vec![100, 32, 57];
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}

// å¯å˜éå†
let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
</code></pre>

<h3>14.2. String</h3>

<pre><code class="language-rust">// åˆ›å»ºå­—ç¬¦ä¸²
let mut s = String::new();
let s = &quot;initial contents&quot;.to_string();
let s = String::from(&quot;initial contents&quot;);

// æ›´æ–°å­—ç¬¦ä¸²
let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
s.push('l');

// æ‹¼æ¥
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2;  // s1 è¢«ç§»åŠ¨äº†ï¼Œä¸èƒ½å†ä½¿ç”¨

// format! å®
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);
let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);

// éå†å­—ç¬¦ä¸²
for c in &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;.chars() {
    println!(&quot;{}&quot;, c);
}

for b in &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
</code></pre>

<h3>14.3. HashMap</h3>

<pre><code class="language-rust">use std::collections::HashMap;

// åˆ›å»º
let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

// è®¿é—®
let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);

match score {
    Some(s) =&gt; println!(&quot;åˆ†æ•°ï¼š{}&quot;, s),
    None =&gt; println!(&quot;é˜Ÿä¼ä¸å­˜åœ¨&quot;),
}

// éå†
for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}

// åªåœ¨é”®ä¸å­˜åœ¨æ—¶æ’å…¥
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

// æ ¹æ®æ—§å€¼æ›´æ–°
let text = &quot;hello world wonderful world&quot;;
let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}
</code></pre>

<h2>15. å¹¶å‘ç¼–ç¨‹</h2>

<h3>15.1. çº¿ç¨‹</h3>

<pre><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;å­çº¿ç¨‹ï¼š{}&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;ä¸»çº¿ç¨‹ï¼š{}&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre>

<h3>15.2. join å¥æŸ„</h3>

<pre><code class="language-rust">use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;å­çº¿ç¨‹ï¼š{}&quot;, i);
        }
    });

    for i in 1..5 {
        println!(&quot;ä¸»çº¿ç¨‹ï¼š{}&quot;, i);
    }

    handle.join().unwrap();  // ç­‰å¾…å­çº¿ç¨‹ç»“æŸ
}
</code></pre>

<h3>15.3. move é—­åŒ…</h3>

<pre><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre>

<h3>15.4. æ¶ˆæ¯ä¼ é€’</h3>

<pre><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;æ”¶åˆ°ï¼š{}&quot;, received);
}
</code></pre>

<h3>15.5. å…±äº«çŠ¶æ€</h3>

<pre><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;ç»“æœï¼š{}&quot;, *counter.lock().unwrap());
}
</code></pre>

<h2>16. æ¨¡å—ç³»ç»Ÿ</h2>

<h3>16.1. åŒ…å’Œ Crate</h3>

<ul>
<li><strong>åŒ… (Package)</strong>: Cargo çš„åŠŸèƒ½ï¼ŒåŒ…å«ä¸€ä¸ª Cargo.toml æ–‡ä»¶</li>
<li><strong>Crate</strong>: æ¨¡å—çš„æ ‘å½¢ç»“æ„ï¼Œäº§ç”Ÿä¸€ä¸ªåº“æˆ–å¯æ‰§è¡Œæ–‡ä»¶</li>
<li><strong>æ¨¡å— (Module)</strong>: æ§åˆ¶ä½œç”¨åŸŸå’Œç§æœ‰æ€§</li>
<li><strong>è·¯å¾„ (Path)</strong>: å‘½åé¡¹çš„æ–¹å¼</li>
</ul>

<h3>16.2. å®šä¹‰æ¨¡å—</h3>

<pre><code class="language-rust">// src/lib.rs
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}

pub fn eat_at_restaurant() {
    // ç»å¯¹è·¯å¾„
    crate::front_of_house::hosting::add_to_waitlist();

    // ç›¸å¯¹è·¯å¾„
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>

<h3>16.3. use å…³é”®å­—</h3>

<pre><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}

// ä½¿ç”¨ as é‡å‘½å
use std::io::Result as IoResult;

// å¯¼å‡ºåç§°
pub use crate::front_of_house::hosting;
</code></pre>

<h3>16.4. æ–‡ä»¶åˆ†ç¦»</h3>

<pre><code>src/
â”œâ”€â”€ main.rs
â”œâ”€â”€ lib.rs
â””â”€â”€ front_of_house/
    â”œâ”€â”€ mod.rs
    â””â”€â”€ hosting.rs
</code></pre>

<p><code>src/lib.rs</code>:</p>

<pre><code class="language-rust">mod front_of_house;

pub use crate::front_of_house::hosting;
</code></pre>

<p><code>src/front_of_house/mod.rs</code>:</p>

<pre><code class="language-rust">pub mod hosting;
</code></pre>

<p><code>src/front_of_house/hosting.rs</code>:</p>

<pre><code class="language-rust">pub fn add_to_waitlist() {}
</code></pre>

<h2>17. æµ‹è¯•</h2>

<h3>17.1. å•å…ƒæµ‹è¯•</h3>

<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }

    #[test]
    #[should_panic]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }

    #[test]
    fn it_works_with_result() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;two plus two does not equal four&quot;))
        }
    }
}
</code></pre>

<p>è¿è¡Œæµ‹è¯•:</p>

<pre><code class="language-bash">cargo test

# è¿è¡Œç‰¹å®šæµ‹è¯•
cargo test test_name

# æ˜¾ç¤ºè¾“å‡º
cargo test -- --show-output

# å¹¶è¡Œæˆ–ä¸²è¡Œ
cargo test -- --test-threads=1
</code></pre>

<h3>17.2. é›†æˆæµ‹è¯•</h3>

<p><code>tests/integration_test.rs</code>:</p>

<pre><code class="language-rust">use my_crate;

#[test]
fn it_adds_two() {
    assert_eq!(4, my_crate::add_two(2));
}
</code></pre>

<h2>18. Cargo å’ŒåŒ…ç®¡ç†</h2>

<h3>18.1. Cargo.toml</h3>

<pre><code class="language-toml">[package]
name = &quot;my_project&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
serde = &quot;1.0&quot;
serde_json = &quot;1.0&quot;
tokio = { version = &quot;1.0&quot;, features = [&quot;full&quot;] }

[dev-dependencies]
criterion = &quot;0.5&quot;

[profile.release]
opt-level = 3
</code></pre>

<h3>18.2. å¸¸ç”¨å‘½ä»¤</h3>

<pre><code class="language-bash"># åˆ›å»ºæ–°é¡¹ç›®
cargo new project_name
cargo new --lib lib_name

# æ„å»º
cargo build
cargo build --release

# è¿è¡Œ
cargo run
cargo run --release

# æ£€æŸ¥
cargo check

# æµ‹è¯•
cargo test

# æ–‡æ¡£
cargo doc --open

# æ›´æ–°ä¾èµ–
cargo update

# æ¸…ç†
cargo clean

# æ ¼å¼åŒ–
cargo fmt

# ä»£ç æ£€æŸ¥
cargo clippy
</code></pre>

<h2>19. æ™ºèƒ½æŒ‡é’ˆ</h2>

<h3>19.1. Box<T></h3>

<pre><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}

// é€’å½’ç±»å‹
enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
</code></pre>

<h3>19.2. Rc<T> å¼•ç”¨è®¡æ•°</h3>

<pre><code class="language-rust">use std::rc::Rc;

enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));

    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));

    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }

    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre>

<h3>19.3. RefCell<T> å†…éƒ¨å¯å˜æ€§</h3>

<pre><code class="language-rust">use std::cell::RefCell;

fn main() {
    let x = RefCell::new(5);

    *x.borrow_mut() += 1;

    println!(&quot;x = {:?}&quot;, x);
}
</code></pre>

<h2>20. ç”Ÿå‘½å‘¨æœŸ</h2>

<h3>20.1. ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨</h3>

<pre><code class="language-rust">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>

<h3>20.2. ç»“æ„ä½“ç”Ÿå‘½å‘¨æœŸ</h3>

<pre><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }

    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre>

<h3>20.3. é™æ€ç”Ÿå‘½å‘¨æœŸ</h3>

<pre><code class="language-rust">let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
</code></pre>

<h2>21. å¼‚æ­¥ç¼–ç¨‹</h2>

<h3>21.1. async/await</h3>

<pre><code class="language-rust">use tokio;

#[tokio::main]
async fn main() {
    let result = fetch_data().await;
    println!(&quot;ç»“æœï¼š{}&quot;, result);
}

async fn fetch_data() -&gt; String {
    // æ¨¡æ‹Ÿå¼‚æ­¥æ“ä½œ
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    String::from(&quot;Data&quot;)
}
</code></pre>

<h3>21.2. å¹¶å‘æ‰§è¡Œ</h3>

<pre><code class="language-rust">use tokio;

#[tokio::main]
async fn main() {
    let task1 = tokio::spawn(async {
        // ä»»åŠ¡ 1
        1
    });

    let task2 = tokio::spawn(async {
        // ä»»åŠ¡ 2
        2
    });

    let result1 = task1.await.unwrap();
    let result2 = task2.await.unwrap();

    println!(&quot;ç»“æœï¼š{} + {} = {}&quot;, result1, result2, result1 + result2);
}
</code></pre>

<h2>22. å® (Macros)</h2>

<h3>22.1. å£°æ˜å®</h3>

<pre><code class="language-rust">#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
</code></pre>

<h3>22.2. è¿‡ç¨‹å®</h3>

<pre><code class="language-rust">use proc_macro;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // å®ç°
}
</code></pre>

<h2>23. å¸¸ç”¨ Crates</h2>

<h3>23.1. Web æ¡†æ¶</h3>

<ul>
<li><strong>actix-web</strong>: é«˜æ€§èƒ½ Web æ¡†æ¶</li>
<li><strong>axum</strong>: ç°ä»£ Web æ¡†æ¶</li>
<li><strong>rocket</strong>: æ˜“ç”¨çš„ Web æ¡†æ¶</li>
<li><strong>warp</strong>: åŸºäºè¿‡æ»¤å™¨çš„ Web æ¡†æ¶</li>
</ul>

<h3>23.2. å¼‚æ­¥è¿è¡Œæ—¶</h3>

<ul>
<li><strong>tokio</strong>: æœ€æµè¡Œçš„å¼‚æ­¥è¿è¡Œæ—¶</li>
<li><strong>async-std</strong>: æ ‡å‡†åº“é£æ ¼çš„å¼‚æ­¥è¿è¡Œæ—¶</li>
</ul>

<h3>23.3. åºåˆ—åŒ–</h3>

<ul>
<li><strong>serde</strong>: åºåˆ—åŒ–å’Œååºåˆ—åŒ–æ¡†æ¶</li>
<li><strong>serde_json</strong>: JSON æ”¯æŒ</li>
<li><strong>bincode</strong>: äºŒè¿›åˆ¶åºåˆ—åŒ–</li>
</ul>

<h3>23.4. å…¶ä»–</h3>

<ul>
<li><strong>clap</strong>: å‘½ä»¤è¡Œå‚æ•°è§£æ</li>
<li><strong>reqwest</strong>: HTTP å®¢æˆ·ç«¯</li>
<li><strong>sqlx</strong>: å¼‚æ­¥ SQL åº“</li>
<li><strong>diesel</strong>: ORM æ¡†æ¶</li>
<li><strong>rayon</strong>: æ•°æ®å¹¶è¡Œ</li>
</ul>

<h2>24. æ€§èƒ½ä¼˜åŒ–</h2>

<h3>24.1. åŸºå‡†æµ‹è¯•</h3>

<pre><code class="language-rust">use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -&gt; u64 {
    match n {
        0 =&gt; 1,
        1 =&gt; 1,
        n =&gt; fibonacci(n-1) + fibonacci(n-2),
    }
}

fn criterion_benchmark(c: &amp;mut Criterion) {
    c.bench_function(&quot;fib 20&quot;, |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
</code></pre>

<h3>24.2. å‘å¸ƒé…ç½®</h3>

<pre><code class="language-toml">[profile.release]
opt-level = 3       # æœ€å¤§ä¼˜åŒ–
lto = true          # é“¾æ¥æ—¶ä¼˜åŒ–
codegen-units = 1   # å‡å°‘ä»£ç ç”Ÿæˆå•å…ƒ
strip = true        # ç§»é™¤ç¬¦å·è¡¨
</code></pre>

<h2>25. æœ€ä½³å®è·µ</h2>

<h3>25.1. å‘½åè§„èŒƒ</h3>

<ul>
<li>ç±»å‹ã€Trait ä½¿ç”¨ <strong>UpperCamelCase</strong></li>
<li>å‡½æ•°ã€å˜é‡ã€æ¨¡å—ä½¿ç”¨ <strong>snake_case</strong></li>
<li>å¸¸é‡ä½¿ç”¨ <strong>SCREAMING_SNAKE_CASE</strong></li>
</ul>

<h3>25.2. é”™è¯¯å¤„ç†</h3>

<ul>
<li>ä½¿ç”¨ <code>Result</code> å’Œ <code>Option</code> è€Œä¸æ˜¯ <code>panic!</code></li>
<li>ä½¿ç”¨ <code>?</code> è¿ç®—ç¬¦ä¼ æ’­é”™è¯¯</li>
<li>ä¸ºè‡ªå®šä¹‰é”™è¯¯å®ç° <code>std::error::Error</code> trait</li>
</ul>

<h3>25.3. æ–‡æ¡£æ³¨é‡Š</h3>

<pre><code class="language-rust">/// è®¡ç®—ä¸¤ä¸ªæ•°çš„å’Œ
///
/// # Examples
///
/// ```
/// let result = add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>

<h3>25.4. ä½¿ç”¨ Clippy</h3>

<pre><code class="language-bash">cargo clippy
</code></pre>

<h2>é™„å½• A: Rust å’Œå…¶ä»–è¯­è¨€å¯¹æ¯”</h2>

<table>
<thead>
<tr>
<th>ç‰¹æ€§</th>
<th>Rust</th>
<th>C++</th>
<th>Go</th>
<th>Python</th>
</tr>
</thead>

<tbody>
<tr>
<td>å†…å­˜å®‰å…¨</td>
<td>ç¼–è¯‘æ—¶ä¿è¯</td>
<td>æ‰‹åŠ¨ç®¡ç†</td>
<td>GC</td>
<td>GC</td>
</tr>

<tr>
<td>æ€§èƒ½</td>
<td>æé«˜</td>
<td>æé«˜</td>
<td>é«˜</td>
<td>ä½</td>
</tr>

<tr>
<td>å­¦ä¹ æ›²çº¿</td>
<td>é™¡å³­</td>
<td>é™¡å³­</td>
<td>å¹³ç¼“</td>
<td>å¹³ç¼“</td>
</tr>

<tr>
<td>å¹¶å‘æ¨¡å‹</td>
<td>æ‰€æœ‰æƒ+ç±»å‹ç³»ç»Ÿ</td>
<td>çº¿ç¨‹+é”</td>
<td>Goroutine</td>
<td>GILé™åˆ¶</td>
</tr>

<tr>
<td>åŒ…ç®¡ç†</td>
<td>Cargo</td>
<td>å¤šç§</td>
<td>go modules</td>
<td>pip</td>
</tr>

<tr>
<td>ç¼–è¯‘é€Ÿåº¦</td>
<td>è¾ƒæ…¢</td>
<td>æ…¢</td>
<td>å¿«</td>
<td>è§£é‡Šæ‰§è¡Œ</td>
</tr>
</tbody>
</table>

<h2>é™„å½• B: å­¦ä¹ èµ„æº</h2>

<ol>
<li><a href="https://doc.rust-lang.org/book/" target="_blank">The Rust Programming Language Book</a> - å®˜æ–¹æ•™ç¨‹</li>
<li><a href="https://doc.rust-lang.org/rust-by-example/" target="_blank">Rust By Example</a> - ç¤ºä¾‹å­¦ä¹ </li>
<li><a href="https://github.com/rust-lang/rustlings" target="_blank">Rustlings</a> - ç»ƒä¹ é¢˜</li>
<li><a href="https://doc.rust-lang.org/std/" target="_blank">Rust API æ–‡æ¡£</a></li>
<li><a href="https://github.com/rust-unofficial/awesome-rust" target="_blank">Awesome Rust</a> - Rust èµ„æºåˆ—è¡¨</li>
</ol>

<h2>é™„å½• C: ç¼–è¾‘å†å²</h2>

<ol>
<li>2025-12-09, tiltwind, åˆç‰ˆ</li>
</ol>
</div>
<script src="//vogo.github.io/markhtml/js/markhtml.js"></script>
</body>
</html>
